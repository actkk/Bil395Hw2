;; A simple Scheme calculator with a REPL
;; We store variables in an alist (association list).

(define vars '())  ;; association list for variables, e.g. ((x . 10) (y . 20))

(define (lookup-var name env)
  (let ((pair (assoc name env)))
    (if pair
        (cdr pair)
        (error "Undefined variable" name))))

(define (tokenize str)
  (let ((result '())
        (current-num "")
        (i 0)
        (len (string-length str)))
    
    (define (flush-num)
      (if (not (string=? current-num ""))
          (begin
            (set! result (append result (list (string->number current-num))))
            (set! current-num ""))))
    
    (while (< i len)
      (let ((c (string-ref str i)))
        (cond
          ((char-numeric? c)
           (set! current-num (string-append current-num (string c))))
          ((or (char=? c #\+) (char=? c #\-) (char=? c #\*) (char=? c #\/))
           (flush-num)
           (set! result (append result (list (string c)))))
          ((char=? c #\()
           (flush-num)
           (set! result (append result (list "("))))
          ((char=? c #\))
           (flush-num)
           (set! result (append result (list ")"))))
          ((char-whitespace? c)
           (flush-num))
          (else
           (error (string-append "Unexpected character: " (string c))))))
      (set! i (+ i 1)))
    
    (flush-num)
    result))

;; İşlem önceliği için yeni recursive descent parser
(define (parse-expression tokens pos)
  (parse-add-sub tokens pos))

(define (parse-add-sub tokens pos)
  (let ((result (parse-mul-div tokens pos)))
    (let loop ((left (car result))
               (new-pos (cadr result)))
      (if (< new-pos (length tokens))
          (let ((token (list-ref tokens new-pos)))
            (if (or (equal? token "+") (equal? token "-"))
                (let ((right-result (parse-mul-div tokens (+ new-pos 1))))
                  (let ((right (car right-result))
                        (next-pos (cadr right-result)))
                    (loop (if (equal? token "+")
                              (+ left right)
                              (- left right))
                          next-pos)))
                (list left new-pos)))
          (list left new-pos)))))

(define (parse-mul-div tokens pos)
  (let ((result (parse-primary tokens pos)))
    (let loop ((left (car result))
               (new-pos (cadr result)))
      (if (< new-pos (length tokens))
          (let ((token (list-ref tokens new-pos)))
            (if (or (equal? token "*") (equal? token "/"))
                (let ((right-result (parse-primary tokens (+ new-pos 1))))
                  (let ((right (car right-result))
                        (next-pos (cadr right-result)))
                    (if (and (equal? token "/") (= right 0))
                        (error "Division by zero")
                        (loop (if (equal? token "*")
                                (* left right)
                                (/ left right))
                              next-pos))))
                (list left new-pos)))
          (list left new-pos)))))

(define (parse-primary tokens pos)
  (if (>= pos (length tokens))
      (error "Unexpected end of expression")
      (let ((token (list-ref tokens pos)))
        (cond
         ((number? token) (list token (+ pos 1)))
         ((equal? token "(")
          (let ((expr-result (parse-expression tokens (+ pos 1))))
            (let ((value (car expr-result))
                  (new-pos (cadr expr-result)))
              (if (>= new-pos (length tokens))
                  (error "Missing closing parenthesis")
                  (if (equal? (list-ref tokens new-pos) ")")
                      (list value (+ new-pos 1))
                      (error "Expected closing parenthesis"))))))
         (else (error (string-append "Unexpected token: " (if (string? token) token (number->string token)))))))))

(define (calculate tokens)
  (if (null? tokens)
      (error "Empty expression")
      (car (parse-expression tokens 0))))

(define (string-contains? str char)
  (let ((len (string-length str)))
    (let loop ((i 0))
      (if (< i len)
          (if (char=? (string-ref str i) char)
              #t
              (loop (+ i 1)))
          #f))))

(define (string-split str char)
  (let ((parts '())
        (current "")
        (i 0)
        (len (string-length str)))
    (while (< i len)
      (let ((c (string-ref str i)))
        (if (char=? c char)
            (begin
              (set! parts (append parts (list current)))
              (set! current ""))
            (set! current (string-append current (string c))))
        (set! i (+ i 1))))
    (set! parts (append parts (list current)))
    parts))

(define (string-trim str)
  (let ((start 0)
        (end (string-length str)))
    (while (and (< start end)
                (char-whitespace? (string-ref str start)))
      (set! start (+ start 1)))
    (while (and (< start end)
                (char-whitespace? (string-ref str (- end 1))))
      (set! end (- end 1)))
    (substring str start end)))

(define (handle-line line)
  (if (string-contains? line #\=)
      (let* ((parts (string-split line #\=))
             (var (string-trim (car parts)))
             (expr (string-trim (cadr parts))))
        (condition-case
         (lambda ()
           (let ((result (calculate (tokenize expr))))
             (set! vars (cons (cons var result) 
                             (filter (lambda (p) (not (equal? (car p) var))) vars)))
             (display var)
             (display " = ")
             (display result)
             (newline)))
         (lambda (err)
           (display "Error: ")
           (display err)
           (newline))))
      (condition-case
       (lambda ()
         (let ((result (calculate (tokenize line))))
           (display "Result: ")
           (display result)
           (newline)))
       (lambda (err)
         (display "Error: ")
         (display err)
         (newline)))))

(define (while condition body)
  (if (condition)
      (begin
        (body)
        (while condition body))))

(define (repl)
  (let loop ()
    (display "> ")
    (force-output)
    (let ((line (let ((line (read-line)))
                  (if (eof-object? line)
                      line 
                      (string-trim line)))))
      (cond
        ((eof-object? line)
         (display "Goodbye!\n"))
        ((string=? line "quit")
         (display "Goodbye!\n"))
        (else
         (handle-line line)
         (loop))))))

(define (read-line)
  (let loop ((chars '()))
    (let ((c (read-char)))
      (cond
        ((or (eof-object? c) (char=? c #\newline))
         (if (eof-object? c)
             c
             (list->string (reverse chars))))
        (else (loop (cons c chars)))))))

(define (condition-case thunk handler)
  (call-with-current-continuation
   (lambda (escape)
     (with-exception-handler
      (lambda (condition) (escape (handler condition)))
      (lambda () (escape (thunk)))))))

(repl)
